import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'tables.dart';

// Generated by drift_dev
part 'database.g.dart';

@DriftDatabase(tables: [InvoicesTable, InvoiceItemsTable, ProductsTable, CustomersTable])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 6; // Bump version for migration from 5 to 6
  
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        if (from < 2) {
          // Migration from v1 to v2 (already done, but good to keep)
          // await m.addColumn(productsTable, productsTable.category); 
        }
        if (from < 3) {
          // Migration from v2 to v3
          await m.createTable(customersTable);
          await m.addColumn(invoicesTable, invoicesTable.targetName);
        }
        if (from < 4) {
          // Migration from v3 to v4
          await m.addColumn(productsTable, productsTable.imagePath);
        }
        if (from < 5) {
          // Migration from v4 to v5
          await m.addColumn(invoicesTable, invoicesTable.discountAmount);
        }
        if (from < 6) {
           // Migration from v5 to v6: Add stockQuantity
           await m.addColumn(productsTable, productsTable.stockQuantity);
        }
      },
    );
  }

  // Invoices
  Future<int> insertInvoice(InvoicesTableCompanion invoice) => into(invoicesTable).insert(invoice);
  Future<int> insertInvoiceItem(InvoiceItemsTableCompanion item) => into(invoiceItemsTable).insert(item);
  Stream<List<InvoicesTableData>> watchAllInvoices() => select(invoicesTable).watch();

  // Invoice History Queries
  Future<List<InvoicesTableData>> getInvoicesByDateRange(DateTime start, DateTime end) {
    return (select(invoicesTable)
      ..where((t) => t.createdAt.isBetweenValues(start, end))
      ..orderBy([(t) => OrderingTerm(expression: t.createdAt, mode: OrderingMode.desc)])
    ).get();
  }

  // Customers
  Future<int> insertCustomer(CustomersTableCompanion customer) => into(customersTable).insert(customer);
  Future<List<CustomersTableData>> getAllCustomers() => select(customersTable).get();
  
  // Check if customer exists by name
  Future<CustomersTableData?> getCustomerByName(String name) {
    return (select(customersTable)..where((t) => t.name.equals(name))).getSingleOrNull();
  }

  // Products
  Future<ProductsTableData?> getProductByName(String name) {
    return (select(productsTable)..where((t) => t.name.equals(name))).getSingleOrNull();
  }
  
  Future<void> updateProductStock(String name, int newStock) {
    return (update(productsTable)..where((t) => t.name.equals(name))).write(ProductsTableCompanion(
      stockQuantity: Value(newStock),
    ));
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));
    return NativeDatabase.createInBackground(file);
  });
}
