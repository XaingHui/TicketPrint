import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'tables.dart';

// Generated by drift_dev
part 'database.g.dart';

@DriftDatabase(tables: [InvoicesTable, InvoiceItemsTable, ProductsTable, CustomersTable])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 5; // Bump version for migration from 4 to 5
  
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        if (from < 2) {
          // Migration from v1 to v2 (already done, but good to keep)
          // await m.addColumn(productsTable, productsTable.category); 
        }
        if (from < 3) {
          // Migration from v2 to v3
          await m.createTable(customersTable);
          await m.addColumn(invoicesTable, invoicesTable.targetName);
        }
        if (from < 4) {
          // Migration from v3 to v4
          await m.addColumn(productsTable, productsTable.imagePath);
        }
        if (from < 5) {
          // Migration from v4 to v5
          await m.addColumn(invoicesTable, invoicesTable.discountAmount);
        }
        if (from < 6) {
          // Migration from v5 to v6 (Fix for missing column if v5 failed)
          // We try to add it. If it exists, sqlite might throw, but drift might handle or we catch it?
          // To be safe, we can just run it. If it fails due to duplicate, the app will crash on open?
          // Ideally we check if column exists, but Drift Migrator doesn't expose easy check.
          // Let's assume it failed before.
          try {
            await m.addColumn(invoicesTable, invoicesTable.discountAmount);
          } catch (e) {
             // Ignore if column already exists
             print("Migration v6: Column might already exist: $e");
          }
        }
      },
    );
  }

  // Invoices
  Future<int> insertInvoice(InvoicesTableCompanion invoice) => into(invoicesTable).insert(invoice);
  Future<int> insertInvoiceItem(InvoiceItemsTableCompanion item) => into(invoiceItemsTable).insert(item);
  Stream<List<InvoicesTableData>> watchAllInvoices() => select(invoicesTable).watch();

  // Invoice History Queries
  Future<List<InvoicesTableData>> getInvoicesByDateRange(DateTime start, DateTime end) {
    return (select(invoicesTable)
      ..where((t) => t.createdAt.isBetweenValues(start, end))
      ..orderBy([(t) => OrderingTerm(expression: t.createdAt, mode: OrderingMode.desc)])
    ).get();
  }

  // Customers
  Future<int> insertCustomer(CustomersTableCompanion customer) => into(customersTable).insert(customer);
  Future<List<CustomersTableData>> getAllCustomers() => select(customersTable).get();
  
  // Check if customer exists by name
  Future<CustomersTableData?> getCustomerByName(String name) {
    return (select(customersTable)..where((t) => t.name.equals(name))).getSingleOrNull();
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));
    return NativeDatabase.createInBackground(file);
  });
}
